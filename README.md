# CVE Analyzer

## CVE to CFG Mapping
Extracting and mapping CVEs to parts of open source programs can be done
by using this part of the repository.
It can be used entirely separately from the rest
and it doesn't have any direct dependency on debloating a container or
kernel. This part might be moved to a independent repository later.
The goal of this part is to automatically map CVEs to functions in the
call graph. This allows us to provide statistics on the number of CVEs
mitigated as a result of removing parts of the code.
The process can be divided into two main phases, phase one, extracting the
CVEs and their details from a publicly available website (currently
cvedetails.com) and phase two, mapping them to functions in the graph.

### Prerequisites
sudo pip3 install bs4
sudo pip3 install lxml
git submodule update --init --recursive

### CVE Scraping
The scraping consists of two main steps. In the first step we scrape the
search results page of a CVE database website.
The URL should be provided by the user as a command-line option and should
require a page ID which should be replaced with a {} so we can
iterate over the results in different pages. In this step we only extract
the URLs for the details pages of all the CVEs.
In the second step, we start scraping the webpage for each of
them looking for specific commit details. In the case of the Linux kernel
we only look for links to git.kernel.org and have parsers for that website.
But this can be extended to support other git online websites and formats.
The output of this section is a multi-level dictionary in the following
format:
dict[cveId][commitId][file] = line number
We dump this dictionary and use it to extract the function names relevant
to each CVE.

The CVE scraping can be run by using the following command:
```
python3.7 cveToFileMapper.py -u [cve-search-page-url] -n 40 -o cveToFile.json -d
```
-u: search page URL
-n: total number of pages
-o: dump file of dictionary
-d: debug enabled/disabled

###Mapper
This phase maps the CVEs extracted in the previous set to specific functions
in the repository. An important point to keep in mind is that the commits
related to each CVE might not be the most current of each file affected by
that commit. And the commit message only specifies the file name and line
number. So, we have to make sure the file we are using the same version
which is specified by the commit to extract the correct function name for
the filename and line number combination.
That's why we need to have access to the relevant repository for this section
to work. When we parse the dictionary dump acquired in the previous phase,
we use the commit ID to checkout the correct version of the file before
trying to idenfity the related function.
After checking out the file, we use cscope to extract function definitions and
line numbers and map the line number in the CVE commit message to the correct
function.
Last we create a CSV file consisting of the CVE and its relevant function name
and line number.

The CVE to function mapping can be done by using the following command:
```
python3 cveToFunctionMapper.py -r /home/hamed/linux-kernel/linux/ -c /home/hamed/container-debloating/cveToFile.json -d
```
-r: repo path
-c: dictionary dump created in the previous step
-d: debug disabled/enabled

###CFG and Debloating
The final step which can be used if the CVEs are being extracted to measure
debloating effectiveness is to count number of CVEs mitigated due to removal
of a set of functions from the CFG.
```
python3.7 cfgToCveMapper.py -c linux.kernel.wo.ia32compat.cleaned.cfg -f syscall.starts.txt -v cvetofile.new.csv -d
```
-c: call function graph
-f: list of starting points in call graph which we want to extract CVEs for
-v: output of cveToFunctionMapper.py which is a csv in the following format cveid,commitid,filename,linenumber,functionname
-i: inverse the results, show CVEs related to all functions not in the specified file
-d: debug enabled/disabled

## Application to Config driven specialization

```
python3.7 cfgToCveMultiMapperForConfigDriven.py -c kernel.outs/linux.kernel.wo.ia32compat.cleaned.cfg -o config-driven-output/ -v kernel.outs/cveToFunctions.nvd.csv -f config-driven-output/syscallFileNames.csv --json
```

-c: call graph
-o: path to folder where we store all output files
-v: output of cveToFunctionMapper.py which is a csv in the following format cveid,commitid,filename,linenumber,functionname
-f: file which has a list of the syscall output generated by configDrivenSyscallSpecialization.py for each application (appname;filepath)
--json: has to be enabled
--temporal: specify when we want to generate CVEs for temporal
--configdriven: specify when we want to generate CVEs for config-driven


## Parse CVE Descriptions
Some of the mappings cannot be extracted through the call due to overapproximations.
So we use text processing on the description to identify these mappings.

After downloading the updated list of kernel CVEs from 
https://github.com/nluedtke/linux_kernel_cves/blob/master/data/kernel_cves.json
we can use the script below to parse them and extract the mapping.

```
python3.8 parseKernelCveJson.py --jsonpath kernel_cves.github.json --outputpath /tmp/tmp
```

## Prerequisites

This project has only been tested on Ubuntu 18.04. Due to usage of specific
debian-based tools (such as dpkg and apt-file) use on other operating systems
at your own risk.
All the scripts have been written in coordinance with python version 3.7.

import os, sys, subprocess, signal
import logging
import optparse

sys.path.insert(0, './python-utils')

import util
import graph
import callfunctiongraph

def isValidOpts(opts):
    """
    Check if the required options are sane to be accepted
        - Check if the provided files exist
        - Check if two sections (additional data) exist
        - Read all target libraries to be debloated from the provided list
    :param opts:
    :return:
    """
    if not options.cfginput or not options.separator or not options.functionlistfile or not options.cvefilepath:
        parser.error("Both options -c, -s, -f and -v should be provided.")
        return False

    return True

def getCvesForFunctionSet(functionSet, funcToCveDict, logger):
    cveSet = set()
    for function in functionSet:
        currentCveSet = funcToCveDict.get(function, None)
        if ( currentCveSet ):
            cveSet.update(currentCveSet)
    return cveSet

def mapCfgToCveWithStartNodes(cfginput, separator, inputStartNode, cvefilepath, inverse, debug, rootLogger, myCfg=None):
    #Extract CVE to function mapping from file
    rootLogger.info("Starting to create function to CVE map from file: %s", cvefilepath)
    cveFile = open(cvefilepath, 'r')
    functionToCveDict = dict()
    functionToFileDict = dict()
    cveLine = cveFile.readline()
    while cveLine:
        #CVE-2019-15292,6377f787aeb945cae7abbb6474798de129e1f3ac,net/appletalk/atalk_proc.c,237,atalk_proc_init
        splittedLine = cveLine.split(",")
        if ( len(splittedLine) == 5 ):
            cve = splittedLine[0]
            funcName = splittedLine[4].strip()
            fileName = splittedLine[2].strip()
            cveSet = functionToCveDict.get(funcName, set())
            cveSet.add(cve)
            functionToCveDict[funcName] = cveSet
            fileSet = functionToFileDict.get(funcName, set())
            fileSet.add(fileName)
            if ( len(fileSet) > 1 ):
                rootLogger.warning("Function: %s has been defined in more than one file: %s, this will invalidate our results!", funcName, str(fileSet))
            functionToFileDict[funcName] = fileSet

        else:
            rootLogger.warning("CVE file has line with wrong number of commas (4): %s", cveLine)
        cveLine = cveFile.readline()
    cveFile.close()


    #Create CFG from input file
    rootLogger.info("Starting to create CFG from file: %s", cfginput)
    if ( not myCfg ):
        myGraph = graph.Graph(rootLogger)
        myGraph.createGraphFromInput(cfginput, separator)
        myCfg = callfunctiongraph.CallFunctionGraph(myGraph, rootLogger, cfginput)
    #inputReachableSet, inputUnreachableSet, startNodeToCveDict, cveToStartNodeDict = myCfg.partitionCfg(inputStartNode, functionToCveDict)
    startNodeToCveDict, cveToStartNodeDict = myCfg.integrateCves(inputStartNode, functionToCveDict)

    #New Implementation 1.27.2020
    startNodeCveSet = set()
    otherNodeCveSet = set()
    cveToStartNodes = dict()
    for startNode, cveSet in startNodeToCveDict.items():
        rootLogger.debug("startNode: %s, len(cveSet): %d", startNode, len(cveSet))
        for cve in cveSet:
            startNodeSet = cveToStartNodes.get(cve, set())
            startNodeSet.add(startNode)
            cveToStartNodes[cve] = startNodeSet
        if ( startNode in inputStartNode ):
            startNodeCveSet.update(cveSet)
        #else:
        #    otherNodeCveSet.update(cveSet)
        #TESTING: what if we only consider CVEs accessible from system calls
        elif ( "__x64_sys" in startNode ):
            otherNodeCveSet.update(cveSet)

    rootLogger.info("Exclusive CVE set removable by input functions: %d, %s", len(set(startNodeCveSet-otherNodeCveSet)), str(set(startNodeCveSet-otherNodeCveSet)))

    return set(startNodeCveSet-otherNodeCveSet), cveToStartNodes, myCfg

    #rootLogger.info("input reachable set of functions: %s", str(inputReachableSet))
    #rootLogger.info("input unreachable set of functions: %s", str(inputUnreachableSet))
    #finalRequiredSet = requiredSet# - unrequiredSet
    #finalUnrequiredSet = unrequiredSet# - requiredSet
    #rootLogger.info("reachable set: %s", str(finalUnrequiredSet))


    '''The reason that we need both of the following is as follows:
    # funcA -> cve1
    # funcB -> cve1
    funcA is in the reachable functions, and funcB is in the nonreachable functions
    can we consider cve1 as fixed?
    NO, so we have to compute the CVEs from both the reachable and nonreachable set of functions and subtract them. 
    That's the final CVE set that we can remove!
    '''
    #Commented for New Implementation 1.27.2020
    '''
    inverseStartNodeCveSet = getCvesForFunctionSet(inputUnreachableSet, functionToCveDict, rootLogger)
    startNodeCveSet = getCvesForFunctionSet(inputReachableSet, functionToCveDict, rootLogger)

    rootLogger.debug("inverseStartNodeCveSet: (len: %d) %s", len(inverseStartNodeCveSet), str(inverseStartNodeCveSet))
    rootLogger.debug("startNodeCveSet: (len: %d) %s", len(startNodeCveSet), str(startNodeCveSet))
    #requiredCveSet = getCvesForFunctionSet(requiredSet, functionToCveDict, rootLogger)
    #unrequiredCveSet = getCvesForFunctionSet(unrequiredSet, functionToCveDict, rootLogger)
    if ( inverse ):
        inverseStartNodeCveSet = inverseStartNodeCveSet - startNodeCveSet
        rootLogger.info("CVEs related to inverse set of functions: count: %d set: %s", len(inverseStartNodeCveSet), str(inverseStartNodeCveSet))
    else:
        startNodeCveSetExclusive = startNodeCveSet - inverseStartNodeCveSet
        rootLogger.info("CVEs exclusively related to passed function: count: %d set: %s", len(startNodeCveSetExclusive), str(startNodeCveSetExclusive))
        if ( startNodeToCveDict ):
            cveToStartNodeExclusiveDict = dict()
            cveToStartNodeDict = dict()
            for cve in startNodeCveSet:
                for startNode, cveSet in startNodeToCveDict.items():
                    if ( cve in cveSet ):
                        tempSet = cveToStartNodeDict.get(cve, set())
                        tempSet.add(startNode)
                        if ( cve in startNodeCveSetExclusive ):
                            cveToStartNodeExclusiveDict[cve] = tempSet
                        else:
                            cveToStartNodeDict[cve] = tempSet
            rootLogger.info("/////////////////////All start nodes (non-exclusive)////////////////////")
            for cve, startNodes in cveToStartNodeDict.items():
                rootLogger.info("cve: %s len(startNodes): %d startNodes: %s", cve, len(startNodes),  str(startNodes))
            rootLogger.info("/////////////////////All start nodes (exclusive)////////////////////")
            for cve, startNodes in cveToStartNodeExclusiveDict.items():
                rootLogger.info("cve: %s len(startNodes): %d startNodes: %s", cve, len(startNodes), str(startNodes))
#    rootLogger.info("CVEs which could've been removed if they weren't used: count: %d set: %s", len(unrequiredCveSet), str(unrequiredCveSet))
    '''

def setLogPath(logPath):
    """
    Set the property of the logger: path, config, and format
    :param logPath:
    :return:
    """
    if os.path.exists(logPath):
        os.remove(logPath)

    rootLogger = logging.getLogger("coverage")
    if options.debug:
        logging.basicConfig(filename=logPath, level=logging.DEBUG)
        rootLogger.setLevel(logging.DEBUG)
    else:
        logging.basicConfig(filename=logPath, level=logging.INFO)
        rootLogger.setLevel(logging.INFO)

#    ch = logging.StreamHandler(sys.stdout)
    consoleHandler = logging.StreamHandler()
    rootLogger.addHandler(consoleHandler)
    return rootLogger
#    rootLogger.addHandler(ch)

if __name__ == '__main__':
    """
    Find system calls for function
    """
    usage = "Usage: %prog -c <Callgraph> -s <Separator in callgraph file llvm=-> glibc=: > -f <Function name>"

    parser = optparse.OptionParser(usage=usage, version="1")

    parser.add_option("-c", "--cfginput", dest="cfginput", default=None, nargs=1,
                      help="CFG input for creating graph from CFG")

    parser.add_option("-s", "--separator", dest="separator", default="->", nargs=1,
                      help="CFG file separator per line")

    parser.add_option("-f", "--functionlist", dest="functionlistfile", default=None, nargs=1,
                      help="Path to file containing list of starting functions")

    parser.add_option("-v", "--cvefile", dest="cvefilepath", default=None, nargs=1,
                      help="Path to file containing CVE to file and function mapping")

    parser.add_option("-i", "--inverse", dest="inverse", default=False, nargs=1,
                      help="Extract CVEs related to functions NOT in the input functions' CFG")

    parser.add_option("-o", "--output", dest="output", default="cveToStartNodes.csv", nargs=1,
                      help="Path to output file")

    parser.add_option("-d", "--debug", dest="debug", action="store_true", default=False,
                      help="Debug enabled/disabled")

    (options, args) = parser.parse_args()
    if isValidOpts(options):
        rootLogger = setLogPath("cfgtocve.log")
        prefixes = ["", "__x64_sys_"]
        suffixes = ["", "_time64", "_time32", "_time64_time32"]
        inputList = set()

        inputListFile = open(options.functionlistfile, 'r')
        inputLine = inputListFile.readline()
        while ( inputLine ):
            for prefix in prefixes:
                for suffix in suffixes:
                    inputList.add(prefix + inputLine.strip() + suffix)
            inputLine = inputListFile.readline()

        exclusiveStartNodeSet, cveToStartNodeDict, cfgObj = mapCfgToCveWithStartNodes(options.cfginput, options.separator, inputList, options.cvefilepath, options.inverse, options.debug, rootLogger)

        outputFile = open(options.output, 'w')

        for cve, startNodes in cveToStartNodeDict.items():
            rootLogger.info(cve + ";" + str(startNodes))
            outputFile.write(cve + ";" + str(startNodes) + "\n")
            outputFile.flush()

        outputFile.close()

import os, sys, subprocess, signal
import logging
import optparse

import json

sys.path.insert(0, './python-utils')


def isValidOpts(opts):
    """
    Check if the required options are sane to be accepted
        - Check if the provided files exist
        - Check if two sections (additional data) exist
        - Read all target libraries to be debloated from the provided list
    :param opts:
    :return:
    """
    if not options.jsonpath or not options.outputpath:
        parser.error("All options -j and -o should be provided.")
        return False

    return True


def setLogPath(logPath):
    """
    Set the property of the logger: path, config, and format
    :param logPath:
    :return:
    """
    if os.path.exists(logPath):
        os.remove(logPath)

    rootLogger = logging.getLogger("coverage")
    if options.debug:
        logging.basicConfig(filename=logPath, level=logging.DEBUG)
        rootLogger.setLevel(logging.DEBUG)
    else:
        logging.basicConfig(filename=logPath, level=logging.INFO)
        rootLogger.setLevel(logging.INFO)

#    ch = logging.StreamHandler(sys.stdout)
    consoleHandler = logging.StreamHandler()
    rootLogger.addHandler(consoleHandler)
    return rootLogger
#    rootLogger.addHandler(ch)

def addItemsToArray(inputArray, startIndex, endIndex):
    result = []
    while ( startIndex <= endIndex ):
        result.append(inputArray[startIndex])
        startIndex += 1
    return result

def getLastWords(inputText, key, count):
    result = []
    splittedByKey = inputText.split(key)
    inputText = splittedByKey[0].strip()
    tokens = inputText.split()
    if ( len(tokens) >= count ):
        startIndex = len(tokens) - count
        result = addItemsToArray(tokens, startIndex, startIndex+count-1)
    if ( len(tokens) < count ):
        result = addItemsToArray(tokens, 0, len(tokens) - 1)
    return result

def convertArrayToStr(inputArr, startIndex, endIndex, separator, prefix = None, clean = False):
    result = ""
    while ( startIndex <= endIndex ):
        if ( clean ):
            inputArr[startIndex] = inputArr[startIndex].replace("()", "")
        if ( prefix ):
            inputArr[startIndex] = prefix + inputArr[startIndex]
        result += inputArr[startIndex] + separator
        startIndex += 1
    return result

def getSyscallName(syscall):
    if ( syscall == "exec" ):
        syscall = "execve"
    syscall = "__x64_sys_" + syscall
    return syscall

def parseNvdText(inputText):
    syscallNames = []
    tokens = getLastWords(inputText, "system call", 5)
    lastIndex = len(tokens) - 1
    syscallNames.append(getSyscallName(tokens[lastIndex]))   # the last word before system call is always a syscall name
    if ( tokens[lastIndex-1].strip() == "(2)" ):
        syscallNames.append(getSyscallName(tokens[lastIndex-3]))
    elif ( tokens[lastIndex-1].strip() == "or" ):
        syscallNames.append(getSyscallName(tokens[lastIndex-2]))
    elif ( tokens[lastIndex-1].strip() == "and" ):
        syscallNames.append(getSyscallName(tokens[lastIndex-2]))
    syscallNamesStr = convertArrayToStr(syscallNames, 0, len(syscallNames)-1, ",", clean=True)
    if ( syscallNamesStr.endswith(",") ):
        syscallNamesStr = syscallNamesStr[:-1]
    return syscallNamesStr

def splitBySyscall(inputText):
    instances = []
    split = inputText.split("system call")
    i = 0
    while ( i < len(split)-1 ):
        instance = split[i] + " system call"
        instances.append(instance)
        i += 1
    if ( inputText.endswith("system call") ):
        instances.append(split[len(split)-1] + " system call")
    return instances
    

def execsArbitraryCode(inputText):
    if ( "execute arbitrary code" in inputText ):
        return True
    return False

if __name__ == '__main__':
    """
    Main function for finding physical memory usage of process
    """
    usage = "Usage: %prog -e <Target executable path> -p <PID of process to retrieve information about>"

    parser = optparse.OptionParser(usage=usage, version="1")

    parser.add_option("-j", "--jsonpath", dest="jsonpath", default=None, nargs=1,
                      help="CVE JSON input path")

    parser.add_option("-o", "--outputpath", dest="outputpath", default=None, nargs=1,
                      help="Path to output file")

    parser.add_option("-d", "--debug", dest="debug", action="store_true", default=False,
                      help="Debug enabled/disabled")

    (options, args) = parser.parse_args()
    if isValidOpts(options):
        rootLogger = setLogPath("parsekernelcvejson.log")
        try:
            cveJsonFile = open(options.jsonpath, 'r')
            cveJsonStr = cveJsonFile.read()
            cveJsonMap = json.loads(cveJsonStr)
        except Exception as e:
            rootLogger.warning("Trying to load cve json from: %s, but doesn't exist: %s", options.jsonpath, str(e))
            rootLogger.debug("Finished loading json")
            sys.exit(-1)

    outputFile = open(options.outputpath, 'w')

    for cveId, cveProp in cveJsonMap.items():
        nvdText = cveProp.get("nvd_text", None)
        if ( not nvdText ):
            continue
        if ( "system call" in nvdText ):
            syscallInstances = splitBySyscall(nvdText)
            #rootLogger.debug("cveId: %s syscallInstances: %s", cveId, str(syscallInstances))
            for syscallInstance in syscallInstances:
                syscallNames = parseNvdText(syscallInstance)
                if ( not syscallNames or syscallNames == "" ):
                    continue
                outputFile.write(cveId + ";" + syscallNames + "\n")
        elif ( "exec" in nvdText ):
            syscallNames = "__x64_sys_execve,__x64_sys_execveat"
            if ( execsArbitraryCode(nvdText) ):
                continue
            if ( "exec operation" in nvdText ):
                outputFile.write(cveId + ";" + syscallNames + ";potentially\n")
            elif ( "execute a " in nvdText and 
                            ("application" in nvdText or 
                            "program" in nvdText) ):
                outputFile.write(cveId + ";" + syscallNames + ";potentially\n")
            elif ( "executing a " in nvdText and 
                            ("application" in nvdText or 
                            "program" in nvdText) ):
                outputFile.write(cveId + ";" + syscallNames + ";potentially\n")
            #syscallInstances = splitBySyscall(nvdText)
            else:
                rootLogger.debug("cveId: %s exec nvdText: %s", cveId, nvdText)
            #for syscallInstance in syscallInstances:
            #    syscallNames = parseNvdText(syscallInstance)
            #    if ( not syscallNames or syscallNames == "" ):
            #        continue
            #    outputFile.write(cveId + ";" + syscallNames + "\n")
    outputFile.close()

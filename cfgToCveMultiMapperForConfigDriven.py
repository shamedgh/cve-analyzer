import os, sys, subprocess, signal
import logging
import optparse

import cfgToCveMapper 

sys.path.insert(0, './python-utils')
import util

def isValidOpts(opts):
    """
    Check if the required options are sane to be accepted
        - Check if the provided files exist
        - Check if two sections (additional data) exist
        - Read all target libraries to be debloated from the provided list
    :param opts:
    :return:
    """
    if not options.cfginput or not options.separator or not options.functionlistfiles or not options.cvefilepath or not options.outputpath:
        parser.error("All options -c, -s, -o, -f and -v should be provided.")
        return False

    return True

def convertStrToList(inputStr):
    inputStr = str(inputStr)
    inputStr = inputStr.replace("{", "")
    inputStr = inputStr.replace("}", "")
    inputStr = inputStr.replace("'", "")
    inputStr = inputStr.replace("\"", "")
    inputStr = inputStr.replace(" ", "")
    return inputStr.split(",")

def setLogPath(logPath):
    """
    Set the property of the logger: path, config, and format
    :param logPath:
    :return:
    """
    if os.path.exists(logPath):
        os.remove(logPath)

    rootLogger = logging.getLogger("coverage")
    if options.debug:
        logging.basicConfig(filename=logPath, level=logging.DEBUG)
        rootLogger.setLevel(logging.DEBUG)
    else:
        logging.basicConfig(filename=logPath, level=logging.INFO)
        rootLogger.setLevel(logging.INFO)

#    ch = logging.StreamHandler(sys.stdout)
    consoleHandler = logging.StreamHandler()
    rootLogger.addHandler(consoleHandler)
    return rootLogger
#    rootLogger.addHandler(ch)

if __name__ == '__main__':
    """
    Find system calls for function
    """
    usage = "Usage: %prog -c <Callgraph> -s <Separator in callgraph file llvm=-> glibc=: > -f <Function name>"

    parser = optparse.OptionParser(usage=usage, version="1")

    parser.add_option("-c", "--cfginput", dest="cfginput", default=None, nargs=1,
                      help="CFG input for creating graph from CFG")

    parser.add_option("-s", "--separator", dest="separator", default="->", nargs=1,
                      help="CFG file separator per line")

    parser.add_option("-f", "--functionlistfiles", dest="functionlistfiles", default=None, nargs=1,
                      help="Path to file containing list of starting functions")

    parser.add_option("-o", "--outputpath", dest="outputpath", default=None, nargs=1,
                      help="Path to store outputs for each application")

    parser.add_option("-v", "--cvefile", dest="cvefilepath", default=None, nargs=1,
                      help="Path to file containing CVE to file and function mapping")

    parser.add_option("-i", "--inverse", dest="inverse", default=False, nargs=1,
                      help="Extract CVEs related to functions NOT in the input functions' CFG")

    parser.add_option("", "--cvetosyscall", dest="cvetosyscall", default=False, nargs=1,
                      help="CVE to system call file (has both automated and manually identified)")

    parser.add_option("", "--piecewise", dest="piecewise", action="store_true", default=False,
                      help="Enable piecewise based debloating results")

    parser.add_option("", "--temporal", dest="temporal", action="store_true", default=False,
                      help="Enable temporal based debloating results")

    parser.add_option("", "--configdriven", dest="configdriven", action="store_true", default=False,
                      help="Enable config-driven debloating results")

    parser.add_option("-d", "--debug", dest="debug", action="store_true", default=False,
                      help="Debug enabled/disabled")

    parser.add_option("", "--json", dest="json", action="store_true", default=False,
                      help="Input file is JSON")

    prefixes = ["__x64_sys_"]
    suffixes = ["", "_time64", "_time32", "_time64_time32"]

    (options, args) = parser.parse_args()
    if isValidOpts(options):
        rootLogger = setLogPath("cfgtocvemulti.log")

        manualCveToSyscallDict = dict()
        if ( options.cvetosyscall ):
            cveToSyscallFile = open(options.cvetosyscall, 'r')
            cveToSyscallLine = cveToSyscallFile.readline()
            while ( cveToSyscallLine ):
                cveToSyscallLine = cveToSyscallLine.strip()
                cve = cveToSyscallLine.split(";")[0]
                syscallStr = cveToSyscallLine.split(";")[1]
                syscallStr = syscallStr.replace("[", "")
                syscallStr = syscallStr.replace("]", "")
                syscallStr = syscallStr.replace("'", "")
                syscallStr = syscallStr.replace("\"", "")
                syscallStr = syscallStr.replace(" ", "")
                syscallStr = syscallStr.replace("\\n", "")
                rootLogger.debug("syscallStr: %s", syscallStr)
                manualCveToSyscallDict[cve] = syscallStr.split(",")
                cveToSyscallLine = cveToSyscallFile.readline()

        if (options.piecewise):
            resultTypes = ["denyPiecewiseMaster"]
        elif (options.temporal):
            resultTypes = ["denyTemporalWorker"]
        elif (options.configdriven):
            resultTypes = ["denyConditionalBbWorker"]
        else:
            resultTypes = ["denyPiecewiseMaster", "denyTemporalWorker", "denyConditionalBbWorker"]

        for resultType in resultTypes:
            cveToAppDict = dict()
            cveToSyscallDict = dict()
            rootLogger.info("running for result type: %s", resultType)
            kernelCfgObj = None
            functionFiles = open(options.functionlistfiles, 'r')
            functionFileLine = functionFiles.readline()
            while ( functionFileLine ):
                if ( not functionFileLine.startswith("#") ):
                    splittedInput = functionFileLine.strip().split(";")
                    if ( len(splittedInput) == 2 ):
                        appName = splittedInput[0]
                        functionFilePath = splittedInput[1]
                        currAppCves = set()
                        rootLogger.info("App: %s function file path: %s", appName, functionFilePath)
                        if ( options.json ):
                            jsonDict = util.readDictFromFile(functionFilePath)

                            #inputStartNode = list()
                            #blImportTable = jsonDict.get("blImportTable", None)
                            #for startNode in blImportTable:
                            #    for prefix in prefixes:
                            #        for suffix in suffixes:
                            #            inputStartNode.append(prefix + startNode + suffix)
                            #cvesExclusivelyReachableFromStartNodes, cveToStartNodes = cfgToCveMapper.mapCfgToCveWithStartNodes(options.cfginput, options.separator, inputStartNode, options.cvefilepath, options.inverse, options.debug, rootLogger)
                            #outputPath = options.outputpath + "/" + appName + ".import.cve.out"
                            #outputFile = open(outputPath, 'w')
                            ##for cve, syscallSet in cvesExclusivelyReachableFromStartNodes.items():
                            #for cve in cvesExclusivelyReachableFromStartNodes:
                            ##    outputFile.write(cve + ";" + str(syscallSet) + "\n")
                            #    outputFile.write(cve + "\n")
                            #    outputFile.flush()
                            #outputFile.close()


                            #inputStartNode = list()
                            #blMaster = jsonDict.get("blTemporalMaster", None)
                            #for startNode in blMaster:
                            #    for prefix in prefixes:
                            #        for suffix in suffixes:
                            #            inputStartNode.append(prefix + startNode + suffix)
                            #cvesExclusivelyReachableFromStartNodes, cveToStartNodes = cfgToCveMapper.mapCfgToCveWithStartNodes(options.cfginput, options.separator, inputStartNode, options.cvefilepath, options.inverse, options.debug, rootLogger)
                            #outputPath = options.outputpath + "/" + appName + ".temporal.master.cve.out"
                            #outputFile = open(outputPath, 'w')
                            ##for cve, syscallSet in cvesExclusivelyReachableFromStartNodes.items():
                            #for cve in cvesExclusivelyReachableFromStartNodes:
                            ##    outputFile.write(cve + ";" + str(syscallSet) + "\n")
                            #    outputFile.write(cve + "\n")
                            #    outputFile.flush()
                            #outputFile.close()

                            inputStartNode = list()
                            blWorker = jsonDict.get(resultType, None)
                            blWorker = convertStrToList(blWorker)
                            for cve, syscallList in manualCveToSyscallDict.items():
                                addCve = True
                                for syscall in syscallList:
                                    syscall = syscall.replace("__x64_sys_", "")     #we shouldn't hve the prefix for matching
                                    if ( syscall not in blWorker ):
                                        addCve = False
                                if ( addCve ):
                                    rootLogger.debug("addCve is true for CVE: %s appName: %s", cve, appName)
                                    cveTypeDict = cveToAppDict.get(cve, dict())
                                    appSet = cveTypeDict.get(resultType, set())
                                    appSet.add(appName)
                                    cveTypeDict[resultType] = appSet
                                    cveToAppDict[cve] = cveTypeDict

                                    cveTypeDict = cveToSyscallDict.get(cve, dict())
                                    syscallSet = cveTypeDict.get(resultType, set())
                                    syscallSet.update(set(syscallList))
                                    cveTypeDict[resultType] = syscallSet
                                    cveToSyscallDict[cve] = cveTypeDict
                                    currAppCves.add(cve)




                            #for startNode in blWorker:
                            #    for prefix in prefixes:
                            #        for suffix in suffixes:
                            #            inputStartNode.append(prefix + startNode + suffix)
                            #cvesExclusivelyReachableFromStartNodes, cveToStartNodes, kernelCfgObj = cfgToCveMapper.mapCfgToCveWithStartNodes(options.cfginput, options.separator, inputStartNode, options.cvefilepath, options.inverse, options.debug, rootLogger, kernelCfgObj)

                            ##for cve, syscallSet in cvesExclusivelyReachableFromStartNodes.items():
                            #for cve in cvesExclusivelyReachableFromStartNodes:

                            #    cveTypeDict = cveToAppDict.get(cve, dict())
                            #    appSet = cveTypeDict.get(resultType, set())
                            #    appSet.add(appName)
                            #    cveTypeDict[resultType] = appSet
                            #    cveToAppDict[cve] = cveTypeDict

                            #    cveTypeDict = cveToSyscallDict.get(cve, dict())
                            #    syscallSet = cveTypeDict.get(resultType, set())
                            #    syscallSet.update(cveToStartNodes.get(cve))
                            #    cveTypeDict[resultType] = syscallSet
                            #    cveToSyscallDict[cve] = cveTypeDict
                            #    currAppCves.add(cve)
                            #    
                            ##    outputFile.write(cve + ";" + str(syscallSet) + "\n")
                            
                            if ( resultType == "denyPiecewiseMaster" ):
                                outputPath = options.outputpath + "/" + appName + ".piecewise.master.cve.out"
                            elif ( resultType == "denyTemporalWorker" ):
                                outputPath = options.outputpath + "/" + appName + ".temporal.worker.cve.out"
                            elif ( resultType == "denyConditionalBbWorker" ):
                                outputPath = options.outputpath + "/" + appName + ".configdriven.worker.cve.out"
                            outputFile = open(outputPath, 'w')
                            for cve in currAppCves:
                                outputFile.write(cve + "\n")
                                outputFile.flush()
                            outputFile.close()

                        else:
                            functionFile = open(functionFilePath, 'r')
                            functionLine = functionFile.readline()
                            inputStartNode = list()
                            while (functionLine):
                                inputStartNode.append(inputStartNode)
                                functionLine = functionFile.readline()
                                cvesExclusivelyReachableFromStartNodes, cveToStartNodes = cfgToCveMapper.mapCfgToCveWithStartNodes(options.cfginput, options.separator, inputStartNode, options.cvefilepath, options.inverse, options.debug, rootLogger)
                                outputPath = options.outputpath + "/" + appName + ".cve.out"
                                outputFile = open(outputPath, 'w')
                                #for cve, syscallSet in cvesExclusivelyReachableFromStartNodes.items():
                                for cve in cvesExclusivelyReachableFromStartNodes:
                                    #outputFile.write(cve + ";" + str(syscallSet) + "\n")
                                    outputFile.write(cve + "\n")
                                    outputFile.flush()
                                outputFile.close()
                functionFileLine = functionFiles.readline()

            if ( resultType == "denyPiecewiseMaster" ):
                outputPath = options.outputpath + "/all.piecewise.master.cve.out"
            elif ( resultType == "denyTemporalWorker" ):
                outputPath = options.outputpath + "/all.temporal.worker.cve.out"
            elif ( resultType == "denyConditionalBbWorker" ):
                outputPath = options.outputpath + "/all.configdriven.worker.cve.out"
            outputFile = open(outputPath, 'w')
            for cve, typeDict in cveToAppDict.items():
                appSet = typeDict.get(resultType, set())
                syscallSet = cveToSyscallDict.get(cve, dict()).get(resultType, set())
                outputFile.write(cve + ";" + str(syscallSet) + ";" + str(appSet) + "\n")
                outputFile.flush()
            outputFile.close()
            

import os, sys, subprocess, signal
import logging
import optparse

import cfgToCveMapper 

sys.path.insert(0, './python-utils')
import util

def isValidOpts(opts):
    """
    Check if the required options are sane to be accepted
        - Check if the provided files exist
        - Check if two sections (additional data) exist
        - Read all target libraries to be debloated from the provided list
    :param opts:
    :return:
    """
    if not options.cfginput or not options.separator or not options.functionlistfiles or not options.cvefilepath or not options.outputpath:
        parser.error("All options -c, -s, -o, -f and -v should be provided.")
        return False

    return True

def convertStrToList(inputStr):
    inputStr = str(inputStr)
    inputStr = inputStr.replace("{", "")
    inputStr = inputStr.replace("}", "")
    inputStr = inputStr.replace("'", "")
    inputStr = inputStr.replace("\"", "")
    inputStr = inputStr.replace(" ", "")
    return inputStr.split(",")

def setLogPath(logPath):
    """
    Set the property of the logger: path, config, and format
    :param logPath:
    :return:
    """
    if os.path.exists(logPath):
        os.remove(logPath)

    rootLogger = logging.getLogger("coverage")
    if options.debug:
        logging.basicConfig(filename=logPath, level=logging.DEBUG)
        rootLogger.setLevel(logging.DEBUG)
    else:
        logging.basicConfig(filename=logPath, level=logging.INFO)
        rootLogger.setLevel(logging.INFO)

#    ch = logging.StreamHandler(sys.stdout)
    consoleHandler = logging.StreamHandler()
    rootLogger.addHandler(consoleHandler)
    return rootLogger
#    rootLogger.addHandler(ch)

if __name__ == '__main__':
    """
    Find system calls for function
    """
    usage = "Usage: %prog -c <Callgraph> -s <Separator in callgraph file llvm=-> glibc=: > -f <Function name>"

    parser = optparse.OptionParser(usage=usage, version="1")

    parser.add_option("-c", "--cfginput", dest="cfginput", default=None, nargs=1,
                      help="CFG input for creating graph from CFG")

    parser.add_option("-s", "--separator", dest="separator", default="->", nargs=1,
                      help="CFG file separator per line")

    parser.add_option("-f", "--functionlistfiles", dest="functionlistfiles", default=None, nargs=1,
                      help="Path to file containing list of starting functions")

    parser.add_option("-o", "--outputpath", dest="outputpath", default=None, nargs=1,
                      help="Path to store outputs for each application")

    parser.add_option("-v", "--cvefile", dest="cvefilepath", default=None, nargs=1,
                      help="Path to file containing CVE to file and function mapping")

    parser.add_option("-i", "--inverse", dest="inverse", default=False, nargs=1,
                      help="Extract CVEs related to functions NOT in the input functions' CFG")

    parser.add_option("", "--cvetosyscall", dest="cvetosyscall", default=False, nargs=1,
                      help="CVE to system call file (has both automated and manually identified)")

    parser.add_option("", "--temporal", dest="temporal", action="store_true", default=False,
                      help="Enable temporal based debloating results")

    parser.add_option("", "--configdriven", dest="configdriven", action="store_true", default=False,
                      help="Enable config-driven debloating results")

    parser.add_option("-d", "--debug", dest="debug", action="store_true", default=False,
                      help="Debug enabled/disabled")

    parser.add_option("", "--json", dest="json", action="store_true", default=False,
                      help="Input file is JSON")

    prefixes = ["__x64_sys_"]
    suffixes = ["", "_time64", "_time32", "_time64_time32"]

    (options, args) = parser.parse_args()
    if isValidOpts(options):
        rootLogger = setLogPath("cfgtocvemulti.log")

        manualCveToSyscallDict = dict()
        if ( options.cvetosyscall ):
            cveToSyscallFile = open(options.cvetosyscall, 'r')
            cveToSyscallLine = cveToSyscallFile.readline()
            while ( cveToSyscallLine ):
                cveToSyscallLine = cveToSyscallLine.strip()
                cve = cveToSyscallLine.split(":")[0]
                syscallStr = cveToSyscallLine.split(":")[1]
                syscallStr = syscallStr.replace("[", "")
                syscallStr = syscallStr.replace("]", "")
                syscallStr = syscallStr.replace("'", "")
                syscallStr = syscallStr.replace("\"", "")
                syscallStr = syscallStr.replace(" ", "")
                syscallStr = syscallStr.replace("\\n", "")
                rootLogger.debug("syscallStr: %s", syscallStr)
                manualCveToSyscallDict[cve] = syscallStr.split(",")
                cveToSyscallLine = cveToSyscallFile.readline()

        cveToAppDict = dict()
        cveToSyscallDict = dict()

        functionFiles = open(options.functionlistfiles, 'r')

        kernelCfgObj = None
        functionFileLine = functionFiles.readline()
        while ( functionFileLine ):
            if ( not functionFileLine.startswith("#") ):
                splittedInput = functionFileLine.strip().split(";")
                if ( len(splittedInput) == 2 ):
                    appName = splittedInput[0]
                    functionFilePath = splittedInput[1]
                    rootLogger.info("App: %s function file path: %s", appName, functionFilePath)
                    if ( options.json ):
                        jsonDict = util.readDictFromFile(functionFilePath)

                        #inputStartNode = list()
                        #blImportTable = jsonDict.get("blImportTable", None)
                        #for startNode in blImportTable:
                        #    for prefix in prefixes:
                        #        for suffix in suffixes:
                        #            inputStartNode.append(prefix + startNode + suffix)
                        #cvesExclusivelyReachableFromStartNodes, cveToStartNodes = cfgToCveMapper.mapCfgToCveWithStartNodes(options.cfginput, options.separator, inputStartNode, options.cvefilepath, options.inverse, options.debug, rootLogger)
                        #outputPath = options.outputpath + "/" + appName + ".import.cve.out"
                        #outputFile = open(outputPath, 'w')
                        ##for cve, syscallSet in cvesExclusivelyReachableFromStartNodes.items():
                        #for cve in cvesExclusivelyReachableFromStartNodes:
                        ##    outputFile.write(cve + ";" + str(syscallSet) + "\n")
                        #    outputFile.write(cve + "\n")
                        #    outputFile.flush()
                        #outputFile.close()


                        #inputStartNode = list()
                        #blMaster = jsonDict.get("blTemporalMaster", None)
                        #for startNode in blMaster:
                        #    for prefix in prefixes:
                        #        for suffix in suffixes:
                        #            inputStartNode.append(prefix + startNode + suffix)
                        #cvesExclusivelyReachableFromStartNodes, cveToStartNodes = cfgToCveMapper.mapCfgToCveWithStartNodes(options.cfginput, options.separator, inputStartNode, options.cvefilepath, options.inverse, options.debug, rootLogger)
                        #outputPath = options.outputpath + "/" + appName + ".temporal.master.cve.out"
                        #outputFile = open(outputPath, 'w')
                        ##for cve, syscallSet in cvesExclusivelyReachableFromStartNodes.items():
                        #for cve in cvesExclusivelyReachableFromStartNodes:
                        ##    outputFile.write(cve + ";" + str(syscallSet) + "\n")
                        #    outputFile.write(cve + "\n")
                        #    outputFile.flush()
                        #outputFile.close()

                        resultType = "denyPiecewiseMaster"
                        if (options.temporal):
                            resultType = "denyTemporalWorker"
                        elif (options.configdriven):
                            resultType = "denyConditionalBbWorker"

                        inputStartNode = list()
                        blWorker = jsonDict.get(resultType, None)
                        blWorker = convertStrToList(blWorker)
                        for cve, syscallList in manualCveToSyscallDict.items():
                            addCve = True
                            for syscall in syscallList:
                                if ( syscall not in blWorker ):
                                    addCve = False
                            if ( addCve ):
                                cveTypeDict = cveToAppDict.get(cve, dict())
                                appSet = cveTypeDict.get(resultType, set())
                                appSet.add(appName)
                                cveTypeDict[resultType] = appSet
                                cveToAppDict[cve] = cveTypeDict

                                cveTypeDict = cveToSyscallDict.get(cve, dict())
                                syscallSet = cveTypeDict.get(resultType, set())
                                syscallSet.update(set(syscallList))
                                cveTypeDict[resultType] = syscallSet
                                cveToSyscallDict[cve] = cveTypeDict




                        for startNode in blWorker:
                            for prefix in prefixes:
                                for suffix in suffixes:
                                    inputStartNode.append(prefix + startNode + suffix)
                        cvesExclusivelyReachableFromStartNodes, cveToStartNodes, kernelCfgObj = cfgToCveMapper.mapCfgToCveWithStartNodes(options.cfginput, options.separator, inputStartNode, options.cvefilepath, options.inverse, options.debug, rootLogger, kernelCfgObj)

                        outputPath = options.outputpath + "/" + appName + ".piecewise.master.cve.out"
                        if ( options.temporal ):
                            outputPath = options.outputpath + "/" + appName + ".temporal.worker.cve.out"
                        elif ( options.configdriven ):
                            outputPath = options.outputpath + "/" + appName + ".configdriven.worker.cve.out"
                        outputFile = open(outputPath, 'w')
                        #for cve, syscallSet in cvesExclusivelyReachableFromStartNodes.items():
                        for cve in cvesExclusivelyReachableFromStartNodes:

                            cveTypeDict = cveToAppDict.get(cve, dict())
                            appSet = cveTypeDict.get(resultType, set())
                            appSet.add(appName)
                            cveTypeDict[resultType] = appSet
                            cveToAppDict[cve] = cveTypeDict

                            cveTypeDict = cveToSyscallDict.get(cve, dict())
                            syscallSet = cveTypeDict.get(resultType, set())
                            syscallSet.update(cveToStartNodes.get(cve))
                            cveTypeDict[resultType] = syscallSet
                            cveToSyscallDict[cve] = cveTypeDict
                            
                        #    outputFile.write(cve + ";" + str(syscallSet) + "\n")
                            outputFile.write(cve + "\n")
                            outputFile.flush()
                        outputFile.close()

                    else:
                        functionFile = open(functionFilePath, 'r')
                        functionLine = functionFile.readline()
                        inputStartNode = list()
                        while (functionLine):
                            inputStartNode.append(inputStartNode)
                            functionLine = functionFile.readline()
                            cvesExclusivelyReachableFromStartNodes, cveToStartNodes = cfgToCveMapper.mapCfgToCveWithStartNodes(options.cfginput, options.separator, inputStartNode, options.cvefilepath, options.inverse, options.debug, rootLogger)
                            outputPath = options.outputpath + "/" + appName + ".cve.out"
                            outputFile = open(outputPath, 'w')
                            #for cve, syscallSet in cvesExclusivelyReachableFromStartNodes.items():
                            for cve in cvesExclusivelyReachableFromStartNodes:
                                #outputFile.write(cve + ";" + str(syscallSet) + "\n")
                                outputFile.write(cve + "\n")
                                outputFile.flush()
                            outputFile.close()
            functionFileLine = functionFiles.readline()

        outputPath = options.outputpath + "/all.piecewise.master.cve.out"
        if ( options.temporal ):
            outputPath = options.outputpath + "/all.temporal.worker.cve.out"
        elif ( options.configdriven ):
            outputPath = options.outputpath + "/all.configdriven.worker.cve.out"
        outputFile = open(outputPath, 'w')
        for cve, typeDict in cveToAppDict.items():
            appSet = typeDict.get(resultType, set())
            syscallSet = cveToSyscallDict.get(cve, dict()).get(resultType, set())
            outputFile.write(cve + ";" + str(syscallSet) + ";" + str(appSet) + "\n")
            outputFile.flush()
        outputFile.close()
            
